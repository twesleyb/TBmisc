verbose = parameters$verbose,
indent = parameters$indent
)
parameters
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
head(v)
v
unique(v)
# Calculate dendrogram from shifted distance matrix.
r = 1.0
dendro <- hclust(as.dist(distm + r), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
length(unique(v))
# Calculate dendrogram from shifted distance matrix.
r = 0
dendro <- hclust(as.dist(distm + r), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
length(unique(v))
# Calculate dendrogram from shifted distance matrix.
r = -1
dendro <- hclust(as.dist(distm + r), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
length(unique(v))
# Calculate dendrogram from shifted distance matrix.
r = -0.5
dendro <- hclust(as.dist(distm + r), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
length(unique(v))
# Calculate dendrogram from shifted distance matrix.
r = -0.1
dendro <- hclust(as.dist(distm + r), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
length(unique(v))
# Calculate dendrogram from shifted distance matrix.
r = 0.1
dendro <- hclust(as.dist(distm + r), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
length(unique(v))
# Calculate dendrogram from shifted distance matrix.
r = 0.2
dendro <- hclust(as.dist(distm + r), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
length(unique(v))
seq(-0.1,0.1, 0.05)
seq(-0.1,0.1, 0.01)
# Calculate dendrogram from shifted distance matrix.
out <- list()
for (i in seq(-0.1,0.1, 0.01)){
r = i
dendro <- hclust(as.dist(distm + r), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
out[[i]] <- length(unique(v))
}
unlist(out)
i
r <- seq(-0.1,0.1, 0.01)
seq_along(r)
# Calculate dendrogram from shifted distance matrix.
out <- list()
r <- seq(-0.1,0.1, 0.01)
# Calculate dendrogram from shifted distance matrix.
out <- list()
r <- seq(-0.1,0.1, 0.01)
for (i in seq_along(r)) {
dendro <- hclust(as.dist(distm + r[i]), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
out[[i]] <- length(unique(v))
}
unlist(out)
# Signed weighted adjacency matrix.
adjm <- silently(bicor,exprDat)^parameters$power
head(adjm)
adjm[1:5,1:5)
distm <- 1 - TOMsimilarity(
adjMat = adjm,
TOMType = parameters$TOMType,
TOMDenom = params$TOMDenom,
suppressTOMForZeroAdjacencies = parameters$suppressTOMForZeroAdjacencies,
useInternalMatrixAlgebra = params$useInternalMatrixAlgebra,
verbose = parameters$verbose,
indent = parameters$indent
)
# Calculate dendrogram from shifted distance matrix.
out <- list()
r <- seq(-0.1,0.1, 0.01)
for (i in seq_along(r)) {
dendro <- hclust(as.dist(distm + r[i]), method = "complete")
v <- cutreeDynamic(
dendro,
cutHeight = parameters$detectCutHeight,
minClusterSize = parameters$minModuleSize,
# Basic tree cut options
method = "hybrid",
distM = distm,
deepSplit = parameters$deepSplit,
# Advanced options
maxCoreScatter = parameters$maxCoreScatter,
minGap = parameters$minGap,
maxAbsCoreScatter = parameters$maxAbsCoreScatter,
minAbsGap = parameters$minAbsGap,
minSplitHeight = parameters$minSplitHeight,
minAbsSplitHeight = parameters$minAbsSplitHeight,
# External (user-supplied) measure of branch split
externalBranchSplitFnc = NULL,
minExternalSplit = NULL,
externalSplitOptions = list(),
externalSplitFncNeedsDistance = NULL,
assumeSimpleExternalSpecification = TRUE,
# PAM stage options
pamStage = parameters$pamStage,
pamRespectsDendro = parameters$pamRespectsDendro,
useMedoids = FALSE,
maxDistToLabel = NULL,
maxPamDist = parameters$detectCutHeight,
respectSmallClusters = TRUE,
# Various options
verbose = parameters$verbose,
indent = parameters$indent
)
out[[i]] <- length(unique(v))
}
unlist(out)
#------------------------------------------------------------------------------
# ## Calculate WS Modularity, the quality of the partition.
#------------------------------------------------------------------------------
# Modularity typically only applies to unsigned graphs.
# Modularity for signed graphs: Gomez et al., 2018
# REF: (https://arxiv.org/abs/0812.3030)
suppressPackageStartupMessages({
require(reshape2, quietly = TRUE)
require(igraph, quietly = TRUE)
require(data.table, quietly = TRUE)
})
# Function to check if value is even.
# If params$power is even then we will need to enforce sign of adjm.
is_even <- function(x){
return((x %% 2) == 0)
}
# Function to write network to file in Pajek format.
write.pajek <- function(adjm, file, ...) {
# Write network adjacency matrix to .net file in Pajek format.
# Uses data.table::fwrite for faster performance.
colnames(adjm) <- rownames(adjm) <- c(1:ncol(adjm))
edge_list <- as.data.table(na.omit(melt(adjm)))
colnames(edge_list) <- c("protA","protB","weight")
v <- as.data.table(paste(seq(1,ncol(adjm)), " \"", seq(1,ncol(adjm)), "\"", sep = ""))
write.table(paste("*Vertices", dim(adjm)[1]), file,
quote = FALSE, row.names = FALSE, col.names = FALSE)
fwrite(v, file, quote = FALSE, sep = " ", row.names = FALSE, col.names = FALSE, append = TRUE)
write.table("*Edges", file, quote = FALSE, row.names = FALSE, col.names = FALSE, append = TRUE)
fwrite(edge_list, file, sep = " ", col.names = FALSE, append = TRUE)
}
# Calculate signed, weighted adjacency matrix.
# Weight (power) affects sign and modularity. If power is even, then ensure that
# sign of interaction is enforced. (negative value ^ even power = positive)
if (is_even(params$power)) {
r <- adjm
r[r<0] <- -1
r[r>0] <- 1
signed_adjm <- r * (adjm^params$power)
} else {
signed_adjm <- adjm^params$power
}
# Write cluster info to file.
script_dir <- paste(project_dir,"bin","radalib", sep="/")
cluster_file <- tempfile(tmpdir = script_dir, fileext = ".clu")
cl <- as.matrix(as.numeric(as.factor(net$colors[match(colnames(adjm), names(net$colors))])))
colnames(cl) <- paste("*Vertices",ncol(signed_adjm))
write.table(cl, quote = FALSE, file = cluster_file, row.names = FALSE, col.names = TRUE)
# Write network to file in Pajak format: use fwrite for faster performance!
network_file <- tempfile(tmpdir = script_dir, fileext = ".net")
write.pajek(signed_adjm, network_file)
# Build a command to be passed to radalib.
script <- "./modularity_calculation.exe"
type <- "WS" # Weighted signed network.
cmd <- paste(script, basename(network_file), basename(cluster_file), type)
# Evaluate modularity of the partition.
# Need to be in radalib/tools directory!
setwd(script_dir)
result <- system(cmd, intern = TRUE, ignore.stderr = TRUE)
setwd(dir)
# Parse the result.
x <- trimws(result[grep(" Q = ", result)])
message(paste("...", x))
Q <- as.numeric(unlist(strsplit(x,"\ "))[4])
# Return score as the inverse of modularity. Bigger is better = smaller.
score <- 1/Q
print(score)
# Remove temporary .net and .clu files.
unlink(network_file)
unlink(cluster_file)
quit()
library(devtools)
library(roxygen2)
devtools::create("TBmiscr")
getwd()
devtools::documnet()
library(devtools)
devtools::document()
install("TBmiscr")
dir
getwd()
