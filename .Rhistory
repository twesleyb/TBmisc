keep[[i]] <- NA
}
i
keep
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
# Keep nodes with >2 connections to core iPSD proteins.
degree_to_stay <- 2
subg <- lapply(as.list(iPSD), function(x) make_ego_graph(g, nodes = x, mode = "all"))
uniong <- lapply(subg, function(x) do.call(igraph::union, x))
dist <- lapply(uniong, function(x) distances(x, mode="all", algorithm = "unweighted"))
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
for (i in 1:length(dist)){
d <- dist[[1]]
d[d!=1] <- 0
sub <- d[,colnames(d) %in% iPSD]
if(!is.null(dim(sub))) {
deg <- apply(sub,1,sum)
keep[[i]] <- names(deg)[deg >= degree_to_stay]
} else {
keep[[i]] <- NA
}
}
keep
is.na(keep)
degree_to_stay
i = 100
i
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
d <- dist[[1]]
d[d!=1] <- 0
sub <- d[,colnames(d) %in% iPSD]
sub
dim(sub)
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
for (i in 1:length(dist)){
d <- dist[[i]]
d[d!=1] <- 0
sub <- d[,colnames(d) %in% iPSD]
if(!is.null(dim(sub))) {
deg <- apply(sub,1,sum)
keep[[i]] <- names(deg)[deg >= degree_to_stay]
} else {
keep[[i]] <- NA
}
}
keep
is.na(keep)
keep <- keep[!is.na(keep)]
keep <- do.call(keep[!is.na(keep)],c)
keep <- do.call(c,keep[!is.na(keep)])
keep
# Nodes to keep because they have 2 or more connection to seed (iPSD) nodes.
keep <- do.call(c,keep[!is.na(keep)])
keep
# Nodes to keep because they have 2 or more connection to seed (iPSD) nodes.
keep <- c(iPSD,do.call(c,keep[!is.na(keep)]))
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
for (i in 1:length(dist)){
d <- dist[[i]]
d[d!=1] <- 0
sub <- d[,colnames(d) %in% iPSD]
if(!is.null(dim(sub))) {
deg <- apply(sub,1,sum)
keep[[i]] <- names(deg)[deg >= degree_to_stay]
} else {
keep[[i]] <- NA
}
}
# Nodes to keep because they have 2 or more connection to seed (iPSD) nodes.
keep <- c(iPSD,do.call(c,keep[!is.na(keep)]))
keep
# Nodes to keep because they have 2 or more connection to seed (iPSD) nodes.
keep <- unique(c(iPSD,do.call(c,keep[!is.na(keep)])))
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
for (i in 1:length(dist)){
d <- dist[[i]]
d[d!=1] <- 0
sub <- d[,colnames(d) %in% iPSD]
if(!is.null(dim(sub))) {
deg <- apply(sub,1,sum)
keep[[i]] <- names(deg)[deg >= degree_to_stay]
} else {
keep[[i]] <- NA
}
}
# Nodes to keep because they have 2 or more connection to seed (iPSD) nodes.
keep <- unique(c(iPSD,do.call(c,keep[!is.na(keep)])))
keep
g <- induced_subgraph(g, keep)
length(V(g))
length(E(g))
i = 1
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
d <- dist[[i]]
d[d!=1] <- 0
org.Mm.eg.db
keys(org.Mm.eg.db)
mapIds(org.Mm.eg.db, keys = "Ywha*", column = "ENTREZID",keytype = "SYMBOL", multivals = "first")
keys(org.Mm.eg.db)
mapIds(org.Mm.eg.db, keys = "Ywha*", column = "ENTREZID",keytype = "SYMBOL", multivals = "first")
mapIds(org.Mm.eg.db, keys = "Ywha*", column = "ENTREZID", keytype = "SYMBOLS", multivals = "first")
mapIds(org.Mm.eg.db, keys = "Ywha*", column = "ENTREZID", keytype = "SYMBOL", multivals = "first")
xx <- as.list(org.Mm.egALIAS2EG)
head(xx)
nmaes(xx)
names(xx)
db <- as.list(org.Mm.egALIAS2EG)
match("Yhwa*",names(db))
grep("Yhwa*",names(db))
grepl("Yhwa*",names(db))
names(db)
grepl("Ywha*",names(db))
sum(grepl("Ywha*",names(db)))
ywhax <- grepl("Ywha*",names(db))
ywhax <- grep("Ywha*",names(db))
ywhax <- db[grep("Ywha*",names(db))]
ywhax
ywhax <- db[[grep("Ywha*",names(db))]]
ywhax <- unlist(db[grep("Ywha*",names(db))])
ywhax
# Ignore Ywha* proteins
db <- as.list(org.Mm.egALIAS2EG)
ywhax <- unlist(db[grep("Ywha*",names(db))])
d <- dist[[i]]
d[d!=1] <- 0
rownames(d) %in% ywhax
d[rownames(d) %in% ywhax,] <- 0
d
d <- dist[[i]]
d[d!=1] <- 0
d
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
# Ignore Ywha* proteins
db <- as.list(org.Mm.egALIAS2EG)
ywhax <- unlist(db[grep("Ywha*",names(db))])
for (i in 1:length(dist)){
d <- dist[[i]]
d[d!=1] <- 0
d[rownames(d) %in% ywhax,] <- 0 # ignore chaperones.
sub <- d[,colnames(d) %in% iPSD]
if(!is.null(dim(sub))) {
deg <- apply(sub,1,sum)
keep[[i]] <- names(deg)[deg >= degree_to_stay]
} else {
keep[[i]] <- NA
}
}
# Nodes to keep because they have 2 or more connection to seed (iPSD) nodes.
keep <- unique(c(iPSD,do.call(c,keep[!is.na(keep)])))
g <- induced_subgraph(g, keep)
length(V(g))
length(E(g))
# Check topology.
ggplotScaleFreePlot(degree(g,loops = FALSE))
# Check topology.
ggplotScaleFreePlot(degree(g,loops = FALSE), nBreaks = 100)
# Check topology.
ggplotScaleFreePlot(degree(g,loops = FALSE), nBreaks = 10)
# Simplify -- remove duplicate edges and self-loops.
g <- simplify(g) # Network topology is not scale-free.
# Send to Cytoscape.
cytoscapePing()
createNetworkFromIgraph(g,"iPSD")
# Generate custome visual theme.
nodeLabels <- mapVisualProperty('node label','symbol','p')
nodeFills <- mapVisualProperty('node fill color','nodeColor','p')
style <- "iPSD"
defaults <- list(NODE_fill = col2hex("grey"),
NODE_SHAPE="Ellipse",
NODE_SIZE = 55,
EDGE_WIDTH = 2.0,
EDGE_TRANSPARENCY=120)
createVisualStyle(style, defaults, list(nodeLabels, nodeFills))
lockNodeDimensions(TRUE, style)
setVisualStyle(style)
# All iPSD proteins.
iPSD <- unique(c(ciPSD$Entrez, iPSD_PTM))
# All PPIs between any iPSD protein and any other protein.
sif <- hitpredict %>% dplyr::filter(Entrez1 %in% iPSD | Entrez2 %in% iPSD) %>%
dplyr::select(Entrez1,Entrez2)
# Data table with node attributes. Gene Names, phosphoprotein, kinases...
noa <- data.table(entrez = unique(c(sif$Entrez1, sif$Entrez2, iPSD)))
noa$symbol <- mapIds(org.Mm.eg.db, keys = noa$entrez, column = "SYMBOL",
keytype = "ENTREZID", multivals = "first")
# Add additional attributes.
kinases <- ciPSD$Kinase
names(kinases) <- ciPSD$Entrez
noa$kinase <- noa$entrez %in% names(kinases[kinases == 1])
noa$phospho <- noa$entrez %in% iPSD_PTM
noa$iPSD <- noa$entrez %in% iPSD # this is the compiled iPSD
noa$nodeColor <- col2hex("grey")
noa$nodeColor[noa$phospho] <- col2hex("red")
# Generate graph.
g <- graph_from_data_frame(d=sif, vertices = noa, directed = FALSE)
# Remove unconnected components.
connectivity <- components(g)
connected_components <- names(connectivity$membership)[connectivity$membership==1]
g <- induced_subgraph(g, connected_components)
# Check!
is.connected(g)
# Only keep noa in graph.
idx <- noa$entrez %in% names(V(g))
noa <- noa[idx,]
# Check!
all(noa$entrez %in% names(V(g)))
all(names(V(g)) %in% noa$entrez)
# Keep iPSD in graph.
idx <- iPSD %in% names(V(g))
iPSD <- iPSD[idx]
# Keep nodes with >2 connections to core iPSD proteins.
degree_to_stay <- 2
subg <- lapply(as.list(iPSD), function(x) make_ego_graph(g, nodes = x, mode = "all"))
uniong <- lapply(subg, function(x) do.call(igraph::union, x))
dist <- lapply(uniong, function(x) distances(x, mode="all", algorithm = "unweighted"))
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
# Ignore Ywha* proteins
db <- as.list(org.Mm.egALIAS2EG)
ywhax <- unlist(db[grep("Ywha*",names(db))])
for (i in 1:length(dist)){
d <- dist[[i]]
d[d!=1] <- 0
d[rownames(d) %in% ywhax,] <- 0 # ignore chaperones.
sub <- d[,colnames(d) %in% iPSD]
if(!is.null(dim(sub))) {
deg <- apply(sub,1,sum)
keep[[i]] <- names(deg)[deg >= degree_to_stay]
} else {
keep[[i]] <- NA
}
}
# Nodes to keep because they have 2 or more connection to seed (iPSD) nodes.
keep <- unique(c(iPSD,do.call(c,keep[!is.na(keep)])))
# Create graph.
g <- induced_subgraph(g, keep)
length(V(g))
length(E(g))
# Simplify -- remove duplicate edges and self-loops.
g <- simplify(g) # Network topology is not scale-free.
# Send to Cytoscape.
cytoscapePing()
# Simplify -- remove duplicate edges and self-loops.
g <- simplify(g)
# Send to Cytoscape.
cytoscapePing()
createNetworkFromIgraph(g,"iPSD")
# Generate custome visual theme.
nodeLabels <- mapVisualProperty('node label','symbol','p')
nodeFills <- mapVisualProperty('node fill color','nodeColor','p')
style <- "iPSD"
defaults <- list(NODE_fill = col2hex("grey"),
NODE_SHAPE="Ellipse",
NODE_SIZE = 55,
EDGE_WIDTH = 2.0,
EDGE_TRANSPARENCY=120)
createVisualStyle(style, defaults, list(nodeLabels, nodeFills))
lockNodeDimensions(TRUE, style)
setVisualStyle(style)
# All iPSD proteins.
iPSD <- unique(c(ciPSD$Entrez, iPSD_PTM))
# All PPIs between any iPSD protein and any other protein.
sif <- hitpredict %>% dplyr::filter(Entrez1 %in% iPSD | Entrez2 %in% iPSD) %>%
dplyr::select(Entrez1,Entrez2)
# Data table with node attributes. Gene Names, phosphoprotein, kinases...
noa <- data.table(entrez = unique(c(sif$Entrez1, sif$Entrez2, iPSD)))
noa$symbol <- mapIds(org.Mm.eg.db, keys = noa$entrez, column = "SYMBOL",
keytype = "ENTREZID", multivals = "first")
# Add additional attributes.
kinases <- ciPSD$Kinase
names(kinases) <- ciPSD$Entrez
noa$kinase <- noa$entrez %in% names(kinases[kinases == 1])
noa$phospho <- noa$entrez %in% iPSD_PTM
noa$iPSD <- noa$entrez %in% iPSD # this is the compiled iPSD
noa$nodeColor <- col2hex("grey")
noa$nodeColor[noa$phospho] <- col2hex("red")
# Generate graph.
g <- graph_from_data_frame(d=sif, vertices = noa, directed = FALSE)
# Remove unconnected components.
connectivity <- components(g)
connected_components <- names(connectivity$membership)[connectivity$membership==1]
g <- induced_subgraph(g, connected_components)
length(V(g))
# Generate graph.
g <- graph_from_data_frame(d=sif, vertices = noa, directed = FALSE)
length(V(g))
length(V(g))
# Remove unconnected components.
connectivity <- components(g)
connected_components <- names(connectivity$membership)[connectivity$membership==1]
g <- induced_subgraph(g, connected_components)
length(V(g))
# Remove unconnected components.
connectivity <- components(g)
connected_components <- names(connectivity$membership)[connectivity$membership==1]
g <- induced_subgraph(g, connected_components)
length(V(g))
# Check!
is.connected(g)
# Only keep noa in graph.
idx <- noa$entrez %in% names(V(g))
noa <- noa[idx,]
# Check!
all(noa$entrez %in% names(V(g)))
all(names(V(g)) %in% noa$entrez)
# Keep iPSD in graph.
idx <- iPSD %in% names(V(g))
iPSD <- iPSD[idx]
# Keep nodes with >2 connections to core iPSD proteins.
degree_to_stay <- 2
# Get entrez for seeds.
db <- as.list(org.Mm.egALIAS2EG)
names(db)
grep("Pka",names(db))
names(db)
grep("Pka",names(db))
db[grep("Pka",names(db))]
db[grep("Pkaca",names(db))]
names(db) == "Pkaca")
names(db) == "Pkaca"
db[names(db) == "Pkaca"]
pka <- db[names(db) == "Pkaca"]
make_ego_graph(g, nodes = pka)
pka
pka
pka %in% iPSD
names(V(g))
pka %in% names(V(g))
make_ego_graph(g, nodes = pka)
?make_ego_graph
dist <- distances(g, mode="all", algorithm = "unweighted")
head(dist)
dist
dist[1:5,1:5]
dist[dist<1]
colnames(dist) == pka
sum(colnames(dist) == pka)
dist[colnames(dist) == pka]
rownames(dist)[dist[colnames(dist) == pka]==1]
adjacent_vertices(g, v = pka, mode = "all")
# Get entrez for seeds.
db <- as.list(org.Mm.egALIAS2EG)
seed <- db[names(db) == "Pkaca"]
dist <- distances(g, mode="all", algorithm = "unweighted")
rownames(dist)[dist[colnames(dist) == seed]==1]
first_degree <- rownames(dist)[dist[colnames(dist) == seed]==1]
seeds <- rownames(dist)[dist[colnames(dist) == seed]==1]
seeds <- c(seed,rownames(dist)[dist[colnames(dist) == seed]==1])
seeds
subg <- lapply(seeds, function(x) make_ego_graph(g, nodes = x, mode = "all"))
uniong <- lapply(subg, function(x) do.call(igraph::union, x))
dist <- lapply(uniong, function(x) distances(x, mode="all", algorithm = "unweighted"))
# Loop through distance matrices, get nodes with > 2 connections to seed nodes.
# Only consider direct connections, distance == 1.
keep <- list()
# Ignore Ywha* proteins
db <- as.list(org.Mm.egALIAS2EG)
ywhax <- unlist(db[grep("Ywha*",names(db))])
for (i in 1:length(dist)){
d <- dist[[i]]
d[d!=1] <- 0
d[rownames(d) %in% ywhax,] <- 0 # ignore chaperones.
sub <- d[,colnames(d) %in% seeds]
if(!is.null(dim(sub))) {
deg <- apply(sub,1,sum)
keep[[i]] <- names(deg)[deg >= degree_to_stay]
} else {
keep[[i]] <- NA
}
}
# Nodes to keep because they have 2 or more connection to seed (iPSD) nodes.
keep <- unique(c(seeds,do.call(c,keep[!is.na(keep)])))
# Create graph.
g <- induced_subgraph(g, keep)
keep
# Create graph.
g <- induced_subgraph(g, unlist(keep))
# Simplify -- remove duplicate edges and self-loops.
g <- simplify(g)
# Send to Cytoscape.
cytoscapePing()
createNetworkFromIgraph(g,"pka")
# Generate custome visual theme.
nodeLabels <- mapVisualProperty('node label','symbol','p')
nodeFills <- mapVisualProperty('node fill color','nodeColor','p')
style <- "iPSD"
defaults <- list(NODE_fill = col2hex("grey"),
NODE_SHAPE="Ellipse",
NODE_SIZE = 55,
EDGE_WIDTH = 2.0,
EDGE_TRANSPARENCY=120)
createVisualStyle(style, defaults, list(nodeLabels, nodeFills))
lockNodeDimensions(TRUE, style)
setVisualStyle(style)
# Get entrez for seeds.
db <- as.list(org.Mm.egALIAS2EG)
seed <- db[names(db) == "Cdkl5"]
seed
# All iPSD proteins.
iPSD <- unique(c(ciPSD$Entrez, iPSD_PTM))
# All PPIs between any iPSD protein and any other protein.
sif <- hitpredict %>% dplyr::filter(Entrez1 %in% iPSD | Entrez2 %in% iPSD) %>%
dplyr::select(Entrez1,Entrez2)
# Data table with node attributes. Gene Names, phosphoprotein, kinases...
noa <- data.table(entrez = unique(c(sif$Entrez1, sif$Entrez2, iPSD)))
noa$symbol <- mapIds(org.Mm.eg.db, keys = noa$entrez, column = "SYMBOL",
keytype = "ENTREZID", multivals = "first")
# Add additional attributes.
kinases <- ciPSD$Kinase
names(kinases) <- ciPSD$Entrez
noa$kinase <- noa$entrez %in% names(kinases[kinases == 1])
noa$phospho <- noa$entrez %in% iPSD_PTM
noa$iPSD <- noa$entrez %in% iPSD # this is the compiled iPSD
noa$nodeColor <- col2hex("grey")
noa$nodeColor[noa$phospho] <- col2hex("red")
# Generate graph.
g <- graph_from_data_frame(d=sif, vertices = noa, directed = FALSE)
length(V(g))
# Remove unconnected components.
connectivity <- components(g)
connected_components <- names(connectivity$membership)[connectivity$membership==1]
g <- induced_subgraph(g, connected_components)
length(V(g))
# Check!
is.connected(g)
# Only keep noa in graph.
idx <- noa$entrez %in% names(V(g))
noa <- noa[idx,]
# Check!
all(noa$entrez %in% names(V(g)))
all(names(V(g)) %in% noa$entrez)
# Keep iPSD in graph.
idx <- iPSD %in% names(V(g))
iPSD <- iPSD[idx]
# Keep nodes with >2 connections to core iPSD proteins.
degree_to_stay <- 2
# Get entrez for seeds.
db <- as.list(org.Mm.egALIAS2EG)
seed <- db[names(db) == "Cdkl5"]
dist <- distances(g, mode="all", algorithm = "unweighted")
seeds <- c(seed,rownames(dist)[dist[colnames(dist) == seed]==1])
subg <- lapply(seeds, function(x) make_ego_graph(g, nodes = x, mode = "all"))
uniong <- lapply(subg, function(x) do.call(igraph::union, x))
seeds
# Get entrez for seeds.
db <- as.list(org.Mm.egALIAS2EG)
seed <- db[names(db) == "Cdkl5"]
dist <- distances(g, mode="all", algorithm = "unweighted")
seeds <- c(seed,rownames(dist)[dist[colnames(dist) == seed]==1])
seeds
seeds <- c(seed,rownames(dist)[dist[colnames(dist) == seed]==2])
dist <- distances(g, mode="all", algorithm = "unweighted")
seeds <- c(seed,rownames(dist)[dist[colnames(dist) == seed]==2])
seeds
# All iPSD proteins.
iPSD <- unique(c(ciPSD$Entrez, iPSD_PTM))
# All PPIs between any iPSD protein and any other protein.
sif <- hitpredict %>% dplyr::filter(Entrez1 %in% iPSD | Entrez2 %in% iPSD) %>%
dplyr::select(Entrez1,Entrez2)
# Data table with node attributes. Gene Names, phosphoprotein, kinases...
noa <- data.table(entrez = unique(c(sif$Entrez1, sif$Entrez2, iPSD)))
noa$symbol <- mapIds(org.Mm.eg.db, keys = noa$entrez, column = "SYMBOL",
keytype = "ENTREZID", multivals = "first")
# Add additional attributes.
kinases <- ciPSD$Kinase
names(kinases) <- ciPSD$Entrez
noa$kinase <- noa$entrez %in% names(kinases[kinases == 1])
noa$phospho <- noa$entrez %in% iPSD_PTM
noa$iPSD <- noa$entrez %in% iPSD # this is the compiled iPSD
noa$nodeColor <- col2hex("grey")
noa$nodeColor[noa$phospho] <- col2hex("red")
# Generate graph.
g <- graph_from_data_frame(d=sif, vertices = noa, directed = FALSE)
length(V(g))
# Check!
all(noa$entrez %in% names(V(g)))
all(names(V(g)) %in% noa$entrez)
# Keep iPSD in graph.
idx <- iPSD %in% names(V(g))
iPSD <- iPSD[idx]
# Keep nodes with >2 connections to core iPSD proteins.
degree_to_stay <- 2
# Get entrez for seeds.
db <- as.list(org.Mm.egALIAS2EG)
seed <- db[names(db) == "Cdkl5"]
dist <- distances(g, mode="all", algorithm = "unweighted")
seeds <- c(seed,rownames(dist)[dist[colnames(dist) == seed]==2])
seeds
seeds <- c(seed,rownames(dist)[dist[colnames(dist) == seed]==1])
seed
seed %in% names(V(g))
noa
"Kcnq2" %in% noa$symbol
fwrite("hitpredict.csv",hitpredict)
fwrite(hitpredict,"hitpredict.csv")
getwd()
